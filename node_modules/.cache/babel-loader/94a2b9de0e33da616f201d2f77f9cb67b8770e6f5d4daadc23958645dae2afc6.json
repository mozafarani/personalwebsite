{"ast":null,"code":"import _toConsumableArray from \"/Users/mohammedalzafarani/Desktop/personalwebsite/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/mohammedalzafarani/Desktop/personalwebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React from 'react';\nimport { iterateFocusableElements } from '@primer/behaviors/utils';\nvar useMenuInitialFocus = function useMenuInitialFocus(open, containerRef, anchorRef) {\n  /**\n   * We need to pick the first element to focus based on how the menu was opened,\n   * however, we need to wait for the menu to be open to set focus.\n   * This is why we use set openingKey in state and have 2 effects\n   */\n  var _React$useState = React.useState(undefined),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    openingGesture = _React$useState2[0],\n    setOpeningGesture = _React$useState2[1];\n  React.useEffect(function inferOpeningKey() {\n    var anchorElement = anchorRef.current;\n    var clickHandler = function clickHandler(event) {\n      // event.detail === 0 means onClick was fired by Enter/Space key\n      // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail\n      if (event.detail !== 0) setOpeningGesture('mouse-click');\n    };\n    var keydownHandler = function keydownHandler(event) {\n      if (['Space', 'Enter', 'ArrowDown', 'ArrowUp'].includes(event.code)) {\n        setOpeningGesture(event.code);\n      }\n    };\n    anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.addEventListener('click', clickHandler);\n    anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.addEventListener('keydown', keydownHandler);\n    return function () {\n      anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.removeEventListener('click', clickHandler);\n      anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.removeEventListener('keydown', keydownHandler);\n    };\n  }, [anchorRef]);\n\n  /**\n   * Pick the first element to focus based on the key used to open the Menu\n   * Click: anchor\n   * ArrowDown | Space | Enter: first element\n   * ArrowUp: last element\n   */\n  React.useEffect(function moveFocusOnOpen() {\n    if (!open || !containerRef.current) return; // wait till the menu is open\n\n    var iterable = iterateFocusableElements(containerRef.current);\n    if (openingGesture === 'mouse-click') {\n      if (anchorRef.current) anchorRef.current.focus();else throw new Error('For focus management, please attach anchorRef');\n    } else if (openingGesture && ['ArrowDown', 'Space', 'Enter'].includes(openingGesture)) {\n      var firstElement = iterable.next().value;\n      /** We push imperative focus to the next tick to prevent React's batching */\n      setTimeout(function () {\n        return firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus();\n      });\n    } else if ('ArrowUp' === openingGesture) {\n      var elements = _toConsumableArray(iterable);\n      var lastElement = elements[elements.length - 1];\n      setTimeout(function () {\n        return lastElement.focus();\n      });\n    } else {\n      /** if the menu was not opened with the anchor, we default to the first element\n       *  for example: with keyboard shortcut (see stories/fixtures)\n       */\n      var _firstElement = iterable.next().value;\n      setTimeout(function () {\n        return _firstElement === null || _firstElement === void 0 ? void 0 : _firstElement.focus();\n      });\n    }\n  },\n  // we don't want containerRef in dependencies\n  // because re-renders to containerRef while it's open should not fire initialMenuFocus\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [open, openingGesture, anchorRef]);\n};\nexport { useMenuInitialFocus };","map":{"version":3,"names":["React","iterateFocusableElements","useMenuInitialFocus","open","containerRef","anchorRef","useState","undefined","openingGesture","setOpeningGesture","useEffect","inferOpeningKey","anchorElement","current","clickHandler","event","detail","keydownHandler","includes","code","addEventListener","removeEventListener","moveFocusOnOpen","iterable","focus","Error","firstElement","next","value","setTimeout","elements","lastElement","length"],"sources":["/Users/mohammedalzafarani/Desktop/personalwebsite/node_modules/@primer/react/lib-esm/hooks/useMenuInitialFocus.js"],"sourcesContent":["import React from 'react';\nimport { iterateFocusableElements } from '@primer/behaviors/utils';\n\nconst useMenuInitialFocus = (open, containerRef, anchorRef) => {\n  /**\n   * We need to pick the first element to focus based on how the menu was opened,\n   * however, we need to wait for the menu to be open to set focus.\n   * This is why we use set openingKey in state and have 2 effects\n   */\n  const [openingGesture, setOpeningGesture] = React.useState(undefined);\n  React.useEffect(function inferOpeningKey() {\n    const anchorElement = anchorRef.current;\n    const clickHandler = event => {\n      // event.detail === 0 means onClick was fired by Enter/Space key\n      // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail\n      if (event.detail !== 0) setOpeningGesture('mouse-click');\n    };\n    const keydownHandler = event => {\n      if (['Space', 'Enter', 'ArrowDown', 'ArrowUp'].includes(event.code)) {\n        setOpeningGesture(event.code);\n      }\n    };\n    anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.addEventListener('click', clickHandler);\n    anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.addEventListener('keydown', keydownHandler);\n    return () => {\n      anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.removeEventListener('click', clickHandler);\n      anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.removeEventListener('keydown', keydownHandler);\n    };\n  }, [anchorRef]);\n\n  /**\n   * Pick the first element to focus based on the key used to open the Menu\n   * Click: anchor\n   * ArrowDown | Space | Enter: first element\n   * ArrowUp: last element\n   */\n  React.useEffect(function moveFocusOnOpen() {\n    if (!open || !containerRef.current) return; // wait till the menu is open\n\n    const iterable = iterateFocusableElements(containerRef.current);\n    if (openingGesture === 'mouse-click') {\n      if (anchorRef.current) anchorRef.current.focus();else throw new Error('For focus management, please attach anchorRef');\n    } else if (openingGesture && ['ArrowDown', 'Space', 'Enter'].includes(openingGesture)) {\n      const firstElement = iterable.next().value;\n      /** We push imperative focus to the next tick to prevent React's batching */\n      setTimeout(() => firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus());\n    } else if ('ArrowUp' === openingGesture) {\n      const elements = [...iterable];\n      const lastElement = elements[elements.length - 1];\n      setTimeout(() => lastElement.focus());\n    } else {\n      /** if the menu was not opened with the anchor, we default to the first element\n       *  for example: with keyboard shortcut (see stories/fixtures)\n       */\n      const firstElement = iterable.next().value;\n      setTimeout(() => firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus());\n    }\n  },\n  // we don't want containerRef in dependencies\n  // because re-renders to containerRef while it's open should not fire initialMenuFocus\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [open, openingGesture, anchorRef]);\n};\n\nexport { useMenuInitialFocus };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}