{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/mohammedalzafarani/Desktop/personalwebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Children } from 'react';\nvar singleWordTriggerTerminators = new Set([' ', '\\n']);\nvar multiWordTriggerTerminators = new Set(['.', '\\n']);\nvar isWhitespace = function isWhitespace(char) {\n  return /\\s/.test(char);\n};\n\n/**\n * Calculate whether or not suggestions should be shown based on the given state of the\n * input. If they should be shown, returns the show event.\n */\nvar calculateSuggestionsQuery = function calculateSuggestionsQuery(triggers, text, caretLocation) {\n  var _loop = function _loop(_query, _potentialTriggers) {\n    var character = text[i];\n    if (singleWordTriggerTerminators.has(character)) _potentialTriggers = _potentialTriggers.filter(function (t) {\n      return t.multiWord;\n    });\n    if (multiWordTriggerTerminators.has(character)) _potentialTriggers = _potentialTriggers.filter(function (t) {\n      return !t.multiWord;\n    });\n    var _iterator = _createForOfIteratorHelper(_potentialTriggers.filter(function (t) {\n        return character === t.triggerChar;\n      })),\n      _step;\n    try {\n      var _loop2 = function _loop2() {\n        var trigger = _step.value;\n        // Trigger chars must always be preceded by whitespace or be the first character in the input,\n        // and even a multi-word query cannot start with whitespace\n        if ((i === 0 || isWhitespace(text[i - 1])) && !isWhitespace(_query[0])) return {\n          v: {\n            v: {\n              trigger: trigger,\n              query: _query\n            }\n          }\n        };\n        _potentialTriggers = _potentialTriggers.filter(function (t) {\n          return t !== trigger;\n        });\n      };\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _ret2 = _loop2();\n        if (typeof _ret2 === \"object\") return _ret2.v;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    _query = character + _query;\n    query = _query, potentialTriggers = _potentialTriggers;\n  };\n  // Build backwards from the caret location until the most recent trigger character or terminator\n  for (var i = caretLocation - 1, query = '', potentialTriggers = triggers; i >= 0 && potentialTriggers.length > 0; i--) {\n    var _ret = _loop(query, potentialTriggers);\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n  return null;\n};\nvar getSuggestionValue = function getSuggestionValue(suggestion) {\n  return typeof suggestion === 'string' ? suggestion : suggestion.value;\n};\nvar getSuggestionKey = function getSuggestionKey(suggestion) {\n  var _suggestion$key;\n  return typeof suggestion === 'string' ? suggestion : (_suggestion$key = suggestion.key) !== null && _suggestion$key !== void 0 ? _suggestion$key : suggestion.value;\n};\n\n/**\n * Attempts to assert that the child element is of a supported type. This can't be enforced\n * by the type system so it has to be done as a runtime check. This isn't foolproof - a\n * component that forwards a ref to a correct element but does not forward event handlers\n * will not work. But it's the best we can reasonably do.\n */\nfunction requireChildrenToBeInput(child, childRef) {\n  Children.only(child); // Assert that the child is lonely\n  if (\n  // There is no way to know what type the underlying child is until it mounts, so this\n  // will always pass on first render before failing on the second render\n  childRef.current && !(childRef.current instanceof HTMLInputElement) && !(childRef.current instanceof HTMLTextAreaElement)) {\n    throw new TypeError(\"AutocompleteTextarea child must be a component that forwards a ref and props to an <input> or <textarea> element.\");\n  }\n  return child;\n}\n\n/**\n * Combine several event handlers into one. The last handler in the list is called first\n * and no further handlers will be called if `event.preventDefault()` is called.\n */\nvar augmentHandler = function augmentHandler() {\n  for (var _len = arguments.length, handlers = new Array(_len), _key = 0; _key < _len; _key++) {\n    handlers[_key] = arguments[_key];\n  }\n  return function (event) {\n    var _iterator2 = _createForOfIteratorHelper([].concat(handlers).reverse()),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var handler = _step2.value;\n        if (!event.isDefaultPrevented()) handler === null || handler === void 0 ? void 0 : handler(event);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  };\n};\nexport { augmentHandler, calculateSuggestionsQuery, getSuggestionKey, getSuggestionValue, requireChildrenToBeInput };","map":{"version":3,"names":["Children","singleWordTriggerTerminators","Set","multiWordTriggerTerminators","isWhitespace","char","test","calculateSuggestionsQuery","triggers","text","caretLocation","character","i","has","filter","t","multiWord","triggerChar","trigger","query","potentialTriggers","length","getSuggestionValue","suggestion","value","getSuggestionKey","_suggestion$key","key","requireChildrenToBeInput","child","childRef","only","current","HTMLInputElement","HTMLTextAreaElement","TypeError","augmentHandler","handlers","event","reverse","handler","isDefaultPrevented"],"sources":["/Users/mohammedalzafarani/Desktop/personalwebsite/node_modules/@primer/react/lib-esm/drafts/InlineAutocomplete/utils.js"],"sourcesContent":["import { Children } from 'react';\n\nconst singleWordTriggerTerminators = new Set([' ', '\\n']);\nconst multiWordTriggerTerminators = new Set(['.', '\\n']);\nconst isWhitespace = char => /\\s/.test(char);\n\n/**\n * Calculate whether or not suggestions should be shown based on the given state of the\n * input. If they should be shown, returns the show event.\n */\nconst calculateSuggestionsQuery = (triggers, text, caretLocation) => {\n  // Build backwards from the caret location until the most recent trigger character or terminator\n  for (let i = caretLocation - 1, query = '', potentialTriggers = triggers; i >= 0 && potentialTriggers.length > 0; i--) {\n    const character = text[i];\n    if (singleWordTriggerTerminators.has(character)) potentialTriggers = potentialTriggers.filter(t => t.multiWord);\n    if (multiWordTriggerTerminators.has(character)) potentialTriggers = potentialTriggers.filter(t => !t.multiWord);\n    for (const trigger of potentialTriggers.filter(t => character === t.triggerChar)) {\n      // Trigger chars must always be preceded by whitespace or be the first character in the input,\n      // and even a multi-word query cannot start with whitespace\n      if ((i === 0 || isWhitespace(text[i - 1])) && !isWhitespace(query[0])) return {\n        trigger,\n        query\n      };\n      potentialTriggers = potentialTriggers.filter(t => t !== trigger);\n    }\n    query = character + query;\n  }\n  return null;\n};\nconst getSuggestionValue = suggestion => typeof suggestion === 'string' ? suggestion : suggestion.value;\nconst getSuggestionKey = suggestion => {\n  var _suggestion$key;\n  return typeof suggestion === 'string' ? suggestion : (_suggestion$key = suggestion.key) !== null && _suggestion$key !== void 0 ? _suggestion$key : suggestion.value;\n};\n\n/**\n * Attempts to assert that the child element is of a supported type. This can't be enforced\n * by the type system so it has to be done as a runtime check. This isn't foolproof - a\n * component that forwards a ref to a correct element but does not forward event handlers\n * will not work. But it's the best we can reasonably do.\n */\nfunction requireChildrenToBeInput(child, childRef) {\n  Children.only(child); // Assert that the child is lonely\n  if (\n  // There is no way to know what type the underlying child is until it mounts, so this\n  // will always pass on first render before failing on the second render\n  childRef.current && !(childRef.current instanceof HTMLInputElement) && !(childRef.current instanceof HTMLTextAreaElement)) {\n    throw new TypeError(`AutocompleteTextarea child must be a component that forwards a ref and props to an <input> or <textarea> element.`);\n  }\n  return child;\n}\n\n/**\n * Combine several event handlers into one. The last handler in the list is called first\n * and no further handlers will be called if `event.preventDefault()` is called.\n */\nconst augmentHandler = (...handlers) => event => {\n  for (const handler of [...handlers].reverse()) {\n    if (!event.isDefaultPrevented()) handler === null || handler === void 0 ? void 0 : handler(event);\n  }\n};\n\nexport { augmentHandler, calculateSuggestionsQuery, getSuggestionKey, getSuggestionValue, requireChildrenToBeInput };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}