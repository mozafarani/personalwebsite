{"ast":null,"code":"import _slicedToArray from \"/Users/mohammedalzafarani/Desktop/personalwebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React from 'react';\nimport { useInView } from 'react-intersection-observer';\nimport { canUseDOM } from '../utils/environment.js';\nimport useIsomorphicLayoutEffect from '../utils/useIsomorphicLayoutEffect.js';\nimport { getScrollContainer } from '../utils/scroll.js';\n\n/**\n * Calculates the height of the sticky pane such that it always\n * fits into the viewport even when the header or footer are visible.\n */\nfunction useStickyPaneHeight() {\n  var rootRef = React.useRef(null);\n\n  // Default the height to the viewport height\n  var _React$useState = React.useState(dvh(100)),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    height = _React$useState2[0],\n    setHeight = _React$useState2[1];\n  var _React$useState3 = React.useState(0),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    offsetHeader = _React$useState4[0],\n    setOffsetHeader = _React$useState4[1];\n\n  // Create intersection observers to track the top and bottom of the content region\n  var _useInView = useInView(),\n    _useInView2 = _slicedToArray(_useInView, 3),\n    contentTopRef = _useInView2[0],\n    contentTopInView = _useInView2[1],\n    contentTopEntry = _useInView2[2];\n  var _useInView3 = useInView(),\n    _useInView4 = _slicedToArray(_useInView3, 2),\n    contentBottomRef = _useInView4[0],\n    contentBottomInView = _useInView4[1];\n\n  // Calculate the height of the sticky pane based on the position of the\n  // top and bottom of the content region\n  var calculateHeight = React.useCallback(function () {\n    // Uncomment to debug\n    // console.log('Recalculating pane height...')\n\n    var calculatedHeight = '';\n    var scrollContainer = getScrollContainer(rootRef.current);\n    var topRect = contentTopEntry === null || contentTopEntry === void 0 ? void 0 : contentTopEntry.target.getBoundingClientRect();\n\n    // Custom sticky header's height with units\n    var offsetHeaderWithUnits = typeof offsetHeader === 'number' ? \"\".concat(offsetHeader, \"px\") : offsetHeader;\n    if (scrollContainer) {\n      var scrollRect = scrollContainer.getBoundingClientRect();\n      var topOffset = topRect ? Math.max(topRect.top - scrollRect.top, 0) : 0;\n      calculatedHeight = \"calc(\".concat(scrollRect.height, \"px - (max(\").concat(topOffset, \"px, \").concat(offsetHeaderWithUnits, \")))\");\n    } else {\n      var _topOffset = topRect ? Math.max(topRect.top, 0) : 0;\n      calculatedHeight = \"calc(\".concat(dvh(100), \" - (max(\").concat(_topOffset, \"px, \").concat(offsetHeaderWithUnits, \")))\");\n    }\n    setHeight(calculatedHeight);\n  }, [contentTopEntry, offsetHeader]);\n\n  // We only want to add scroll and resize listeners if the pane is sticky.\n  // Since hooks can't be called conditionally, we need to use state to track\n  // if the pane is sticky.\n  var _React$useState5 = React.useState(false),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    isEnabled = _React$useState6[0],\n    setIsEnabled = _React$useState6[1];\n  useIsomorphicLayoutEffect(function () {\n    var scrollContainer = getScrollContainer(rootRef.current);\n    if (isEnabled && (contentTopInView || contentBottomInView)) {\n      calculateHeight();\n\n      // Start listeners if the top or the bottom edge of the content region is visible\n\n      if (scrollContainer) {\n        // eslint-disable-next-line github/prefer-observers\n        scrollContainer.addEventListener('scroll', calculateHeight);\n      } else {\n        // eslint-disable-next-line github/prefer-observers\n        window.addEventListener('scroll', calculateHeight);\n      }\n\n      // eslint-disable-next-line github/prefer-observers\n      window.addEventListener('resize', calculateHeight);\n    }\n    return function () {\n      // Stop listeners if neither the top nor the bottom edge of the content region is visible\n\n      if (scrollContainer) {\n        scrollContainer.removeEventListener('scroll', calculateHeight);\n      } else {\n        window.removeEventListener('scroll', calculateHeight);\n      }\n      window.removeEventListener('resize', calculateHeight);\n    };\n  }, [isEnabled, contentTopInView, contentBottomInView, calculateHeight]);\n  function enableStickyPane(top) {\n    setIsEnabled(true);\n    setOffsetHeader(top);\n  }\n  function disableStickyPane() {\n    setIsEnabled(false);\n  }\n  return {\n    rootRef: rootRef,\n    enableStickyPane: enableStickyPane,\n    disableStickyPane: disableStickyPane,\n    contentTopRef: contentTopRef,\n    contentBottomRef: contentBottomRef,\n    stickyPaneHeight: height\n  };\n}\n\n// TODO: there is currently an issue with dvh on Desktop Safari 15.6, 16.0. To\n// work around it, we check to see if the device supports touch along with the\n// dvh unit in order to target iPad. When the bug is addressed this check will\n// no longer be needed\n//\n// @see https://bugs.webkit.org/show_bug.cgi?id=242758\nvar supportsTouchCallout = canUseDOM ? CSS.supports('-webkit-touch-callout', 'none') : false;\nvar supportsDVH = canUseDOM ? CSS.supports('max-height', '100dvh') && supportsTouchCallout : false;\n\n/**\n * Convert the given value to a dvh value, if supported, otherwise it falls back\n * to vh\n */\nfunction dvh(value) {\n  if (supportsDVH) {\n    return \"\".concat(value, \"dvh\");\n  }\n  return \"\".concat(value, \"vh\");\n}\nexport { useStickyPaneHeight };","map":{"version":3,"names":["React","useInView","canUseDOM","useIsomorphicLayoutEffect","getScrollContainer","useStickyPaneHeight","rootRef","useRef","useState","dvh","height","setHeight","offsetHeader","setOffsetHeader","contentTopRef","contentTopInView","contentTopEntry","contentBottomRef","contentBottomInView","calculateHeight","useCallback","calculatedHeight","scrollContainer","current","topRect","target","getBoundingClientRect","offsetHeaderWithUnits","scrollRect","topOffset","Math","max","top","isEnabled","setIsEnabled","addEventListener","window","removeEventListener","enableStickyPane","disableStickyPane","stickyPaneHeight","supportsTouchCallout","CSS","supports","supportsDVH","value"],"sources":["/Users/mohammedalzafarani/Desktop/personalwebsite/node_modules/@primer/react/lib-esm/PageLayout/useStickyPaneHeight.js"],"sourcesContent":["import React from 'react';\nimport { useInView } from 'react-intersection-observer';\nimport { canUseDOM } from '../utils/environment.js';\nimport useIsomorphicLayoutEffect from '../utils/useIsomorphicLayoutEffect.js';\nimport { getScrollContainer } from '../utils/scroll.js';\n\n/**\n * Calculates the height of the sticky pane such that it always\n * fits into the viewport even when the header or footer are visible.\n */\nfunction useStickyPaneHeight() {\n  const rootRef = React.useRef(null);\n\n  // Default the height to the viewport height\n  const [height, setHeight] = React.useState(dvh(100));\n  const [offsetHeader, setOffsetHeader] = React.useState(0);\n\n  // Create intersection observers to track the top and bottom of the content region\n  const [contentTopRef, contentTopInView, contentTopEntry] = useInView();\n  const [contentBottomRef, contentBottomInView] = useInView();\n\n  // Calculate the height of the sticky pane based on the position of the\n  // top and bottom of the content region\n  const calculateHeight = React.useCallback(() => {\n    // Uncomment to debug\n    // console.log('Recalculating pane height...')\n\n    let calculatedHeight = '';\n    const scrollContainer = getScrollContainer(rootRef.current);\n    const topRect = contentTopEntry === null || contentTopEntry === void 0 ? void 0 : contentTopEntry.target.getBoundingClientRect();\n\n    // Custom sticky header's height with units\n    const offsetHeaderWithUnits = typeof offsetHeader === 'number' ? `${offsetHeader}px` : offsetHeader;\n    if (scrollContainer) {\n      const scrollRect = scrollContainer.getBoundingClientRect();\n      const topOffset = topRect ? Math.max(topRect.top - scrollRect.top, 0) : 0;\n      calculatedHeight = `calc(${scrollRect.height}px - (max(${topOffset}px, ${offsetHeaderWithUnits})))`;\n    } else {\n      const topOffset = topRect ? Math.max(topRect.top, 0) : 0;\n      calculatedHeight = `calc(${dvh(100)} - (max(${topOffset}px, ${offsetHeaderWithUnits})))`;\n    }\n    setHeight(calculatedHeight);\n  }, [contentTopEntry, offsetHeader]);\n\n  // We only want to add scroll and resize listeners if the pane is sticky.\n  // Since hooks can't be called conditionally, we need to use state to track\n  // if the pane is sticky.\n  const [isEnabled, setIsEnabled] = React.useState(false);\n  useIsomorphicLayoutEffect(() => {\n    const scrollContainer = getScrollContainer(rootRef.current);\n    if (isEnabled && (contentTopInView || contentBottomInView)) {\n      calculateHeight();\n\n      // Start listeners if the top or the bottom edge of the content region is visible\n\n      if (scrollContainer) {\n        // eslint-disable-next-line github/prefer-observers\n        scrollContainer.addEventListener('scroll', calculateHeight);\n      } else {\n        // eslint-disable-next-line github/prefer-observers\n        window.addEventListener('scroll', calculateHeight);\n      }\n\n      // eslint-disable-next-line github/prefer-observers\n      window.addEventListener('resize', calculateHeight);\n    }\n    return () => {\n      // Stop listeners if neither the top nor the bottom edge of the content region is visible\n\n      if (scrollContainer) {\n        scrollContainer.removeEventListener('scroll', calculateHeight);\n      } else {\n        window.removeEventListener('scroll', calculateHeight);\n      }\n      window.removeEventListener('resize', calculateHeight);\n    };\n  }, [isEnabled, contentTopInView, contentBottomInView, calculateHeight]);\n  function enableStickyPane(top) {\n    setIsEnabled(true);\n    setOffsetHeader(top);\n  }\n  function disableStickyPane() {\n    setIsEnabled(false);\n  }\n  return {\n    rootRef,\n    enableStickyPane,\n    disableStickyPane,\n    contentTopRef,\n    contentBottomRef,\n    stickyPaneHeight: height\n  };\n}\n\n// TODO: there is currently an issue with dvh on Desktop Safari 15.6, 16.0. To\n// work around it, we check to see if the device supports touch along with the\n// dvh unit in order to target iPad. When the bug is addressed this check will\n// no longer be needed\n//\n// @see https://bugs.webkit.org/show_bug.cgi?id=242758\nconst supportsTouchCallout = canUseDOM ? CSS.supports('-webkit-touch-callout', 'none') : false;\nconst supportsDVH = canUseDOM ? CSS.supports('max-height', '100dvh') && supportsTouchCallout : false;\n\n/**\n * Convert the given value to a dvh value, if supported, otherwise it falls back\n * to vh\n */\nfunction dvh(value) {\n  if (supportsDVH) {\n    return `${value}dvh`;\n  }\n  return `${value}vh`;\n}\n\nexport { useStickyPaneHeight };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}