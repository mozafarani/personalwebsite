{"ast":null,"code":"export function iterateFocusableElements(container) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var _a, _b;\n    const strict = (_a = options.strict) !== null && _a !== void 0 ? _a : false;\n    const acceptFn = ((_b = options.onlyTabbable) !== null && _b !== void 0 ? _b : false) ? isTabbable : isFocusable;\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n      acceptNode: node => node instanceof HTMLElement && acceptFn(node, strict) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n    });\n    let nextNode = null;\n    if (!options.reverse && acceptFn(container, strict)) {\n      yield container;\n    }\n    if (options.reverse) {\n      let lastChild = walker.lastChild();\n      while (lastChild) {\n        nextNode = lastChild;\n        lastChild = walker.lastChild();\n      }\n    } else {\n      nextNode = walker.firstChild();\n    }\n    while (nextNode instanceof HTMLElement) {\n      yield nextNode;\n      nextNode = options.reverse ? walker.previousNode() : walker.nextNode();\n    }\n    if (options.reverse && acceptFn(container, strict)) {\n      yield container;\n    }\n    return undefined;\n  }();\n}\nexport function getFocusableChild(container) {\n  let lastChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return iterateFocusableElements(container, {\n    reverse: lastChild,\n    strict: true,\n    onlyTabbable: true\n  }).next().value;\n}\nexport function isFocusable(elem) {\n  let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const disabledAttrInert = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(elem.tagName) && elem.disabled;\n  const hiddenInert = elem.hidden;\n  const hiddenInputInert = elem instanceof HTMLInputElement && elem.type === 'hidden';\n  const sentinelInert = elem.classList.contains('sentinel');\n  if (disabledAttrInert || hiddenInert || hiddenInputInert || sentinelInert) {\n    return false;\n  }\n  if (strict) {\n    const sizeInert = elem.offsetWidth === 0 || elem.offsetHeight === 0;\n    const visibilityInert = ['hidden', 'collapse'].includes(getComputedStyle(elem).visibility);\n    const clientRectsInert = elem.getClientRects().length === 0;\n    if (sizeInert || visibilityInert || clientRectsInert) {\n      return false;\n    }\n  }\n  if (elem.getAttribute('tabindex') != null) {\n    return true;\n  }\n  if (elem instanceof HTMLAnchorElement && elem.getAttribute('href') == null) {\n    return false;\n  }\n  return elem.tabIndex !== -1;\n}\nexport function isTabbable(elem) {\n  let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return isFocusable(elem, strict) && elem.getAttribute('tabindex') !== '-1';\n}","map":{"version":3,"names":["iterateFocusableElements","container","options","_a","_b","strict","acceptFn","onlyTabbable","isTabbable","isFocusable","walker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","HTMLElement","FILTER_ACCEPT","FILTER_SKIP","nextNode","reverse","lastChild","firstChild","previousNode","undefined","getFocusableChild","next","value","elem","disabledAttrInert","includes","tagName","disabled","hiddenInert","hidden","hiddenInputInert","HTMLInputElement","type","sentinelInert","classList","contains","sizeInert","offsetWidth","offsetHeight","visibilityInert","getComputedStyle","visibility","clientRectsInert","getClientRects","length","getAttribute","HTMLAnchorElement","tabIndex"],"sources":["/Users/mohammedalzafarani/Desktop/personalwebsite/node_modules/@primer/behaviors/dist/esm/utils/iterate-focusable-elements.js"],"sourcesContent":["export function* iterateFocusableElements(container, options = {}) {\n    var _a, _b;\n    const strict = (_a = options.strict) !== null && _a !== void 0 ? _a : false;\n    const acceptFn = ((_b = options.onlyTabbable) !== null && _b !== void 0 ? _b : false) ? isTabbable : isFocusable;\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n        acceptNode: node => node instanceof HTMLElement && acceptFn(node, strict) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n    });\n    let nextNode = null;\n    if (!options.reverse && acceptFn(container, strict)) {\n        yield container;\n    }\n    if (options.reverse) {\n        let lastChild = walker.lastChild();\n        while (lastChild) {\n            nextNode = lastChild;\n            lastChild = walker.lastChild();\n        }\n    }\n    else {\n        nextNode = walker.firstChild();\n    }\n    while (nextNode instanceof HTMLElement) {\n        yield nextNode;\n        nextNode = options.reverse ? walker.previousNode() : walker.nextNode();\n    }\n    if (options.reverse && acceptFn(container, strict)) {\n        yield container;\n    }\n    return undefined;\n}\nexport function getFocusableChild(container, lastChild = false) {\n    return iterateFocusableElements(container, { reverse: lastChild, strict: true, onlyTabbable: true }).next().value;\n}\nexport function isFocusable(elem, strict = false) {\n    const disabledAttrInert = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(elem.tagName) &&\n        elem.disabled;\n    const hiddenInert = elem.hidden;\n    const hiddenInputInert = elem instanceof HTMLInputElement && elem.type === 'hidden';\n    const sentinelInert = elem.classList.contains('sentinel');\n    if (disabledAttrInert || hiddenInert || hiddenInputInert || sentinelInert) {\n        return false;\n    }\n    if (strict) {\n        const sizeInert = elem.offsetWidth === 0 || elem.offsetHeight === 0;\n        const visibilityInert = ['hidden', 'collapse'].includes(getComputedStyle(elem).visibility);\n        const clientRectsInert = elem.getClientRects().length === 0;\n        if (sizeInert || visibilityInert || clientRectsInert) {\n            return false;\n        }\n    }\n    if (elem.getAttribute('tabindex') != null) {\n        return true;\n    }\n    if (elem instanceof HTMLAnchorElement && elem.getAttribute('href') == null) {\n        return false;\n    }\n    return elem.tabIndex !== -1;\n}\nexport function isTabbable(elem, strict = false) {\n    return isFocusable(elem, strict) && elem.getAttribute('tabindex') !== '-1';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}