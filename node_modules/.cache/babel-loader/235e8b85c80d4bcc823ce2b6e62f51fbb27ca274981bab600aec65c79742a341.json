{"ast":null,"code":"import _objectSpread from \"/Users/mohammedalzafarani/Desktop/personalwebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/mohammedalzafarani/Desktop/personalwebsite/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"triggers\", \"suggestions\", \"onShowSuggestions\", \"onHideSuggestions\", \"sx\", \"children\", \"tabInsertsSuggestions\"];\nimport React, { useRef, cloneElement } from 'react';\nimport Box from '../../Box.js';\nimport Portal from '../../Portal/index.js';\nimport { getAbsoluteCharacterCoordinates } from '../utils/character-coordinates.js';\nimport { useSyntheticChange } from '../hooks/useSyntheticChange.js';\nimport { requireChildrenToBeInput, augmentHandler, getSuggestionValue, calculateSuggestionsQuery } from './utils.js';\nimport AutocompleteSuggestions from './_AutocompleteSuggestions.js';\nimport { useRefObjectAsForwardedRef } from '../../hooks/useRefObjectAsForwardedRef.js';\nvar getSelectionStart = function getSelectionStart(element) {\n  try {\n    return element.selectionStart;\n  } catch (e) {\n    // Safari throws an exception when trying to access selectionStart on date input element\n    if (e instanceof TypeError) return null;\n    throw e;\n  }\n};\nvar noop = function noop() {\n  // don't do anything\n};\n\n/**\n * Shows suggestions to complete the current word/phrase the user is actively typing.\n */\nvar InlineAutocomplete = function InlineAutocomplete(_ref) {\n  var triggers = _ref.triggers,\n    suggestions = _ref.suggestions,\n    onShowSuggestions = _ref.onShowSuggestions,\n    onHideSuggestions = _ref.onHideSuggestions,\n    sx = _ref.sx,\n    children = _ref.children,\n    _ref$tabInsertsSugges = _ref.tabInsertsSuggestions,\n    tabInsertsSuggestions = _ref$tabInsertsSugges === void 0 ? false : _ref$tabInsertsSugges,\n    forwardProps = _objectWithoutProperties(_ref, _excluded);\n  var _children$ref, _externalInput$props$, _getSelectionStart;\n  var inputRef = useRef(null);\n  useRefObjectAsForwardedRef((_children$ref = children.ref) !== null && _children$ref !== void 0 ? _children$ref : noop, inputRef);\n  var externalInput = requireChildrenToBeInput(children, inputRef);\n  var emitSyntheticChange = useSyntheticChange({\n    inputRef: inputRef,\n    fallbackEventHandler: (_externalInput$props$ = externalInput.props.onChange) !== null && _externalInput$props$ !== void 0 ? _externalInput$props$ : noop\n  });\n\n  /** Stores the query that caused the current suggestion list to appear. */\n  var showEventRef = useRef(null);\n  var suggestionsVisible = suggestions !== null && suggestions.length > 0;\n\n  // The suggestions don't usually move while open, so it seems as though this could be\n  // optimized by only re-rendering when suggestionsVisible changes. However, the user\n  // could move the cursor to a different location using arrow keys and then type a\n  // trigger, which would move the suggestions without closing/reopening them.\n  var triggerCharCoords = inputRef.current && showEventRef.current && suggestionsVisible ? getAbsoluteCharacterCoordinates(inputRef.current, ((_getSelectionStart = getSelectionStart(inputRef.current)) !== null && _getSelectionStart !== void 0 ? _getSelectionStart : 0) - showEventRef.current.query.length) : {\n    top: 0,\n    left: 0,\n    height: 0\n  };\n  var suggestionsOffset = {\n    top: triggerCharCoords.top + triggerCharCoords.height,\n    left: triggerCharCoords.left\n  };\n\n  // User can blur while suggestions are visible with shift+tab\n  var onBlur = function onBlur() {\n    onHideSuggestions();\n  };\n\n  // Even though the overlay has an Escape listener, it only works when focus is inside\n  // the overlay; in this case the textarea is focused\n  var onKeyDown = function onKeyDown(event) {\n    if (suggestionsVisible && event.key === 'Escape') {\n      onHideSuggestions();\n      event.stopPropagation();\n    }\n  };\n  var onChange = function onChange(event) {\n    var selectionStart = getSelectionStart(event.currentTarget);\n    if (selectionStart === null) {\n      onHideSuggestions();\n      return;\n    }\n    showEventRef.current = calculateSuggestionsQuery(triggers, event.currentTarget.value, selectionStart);\n    if (showEventRef.current) {\n      onShowSuggestions(showEventRef.current);\n    } else {\n      onHideSuggestions();\n    }\n  };\n  var onCommit = function onCommit(suggestion) {\n    var _getSelectionStart2, _trigger$keepTriggerC;\n    if (!inputRef.current || !showEventRef.current) return;\n    var _showEventRef$current = showEventRef.current,\n      query = _showEventRef$current.query,\n      trigger = _showEventRef$current.trigger;\n    var currentCaretPosition = (_getSelectionStart2 = getSelectionStart(inputRef.current)) !== null && _getSelectionStart2 !== void 0 ? _getSelectionStart2 : 0;\n    var deleteLength = query.length + trigger.triggerChar.length;\n    var startIndex = currentCaretPosition - deleteLength;\n    var keepTriggerChar = (_trigger$keepTriggerC = trigger.keepTriggerCharOnCommit) !== null && _trigger$keepTriggerC !== void 0 ? _trigger$keepTriggerC : true;\n    var maybeTriggerChar = keepTriggerChar ? trigger.triggerChar : '';\n    var replacement = \"\".concat(maybeTriggerChar).concat(suggestion, \" \");\n    emitSyntheticChange(replacement, [startIndex, startIndex + deleteLength]);\n    onHideSuggestions();\n  };\n  var input = /*#__PURE__*/cloneElement(externalInput, _objectSpread(_objectSpread({}, forwardProps), {}, {\n    onBlur: augmentHandler(externalInput.props.onBlur, onBlur),\n    onKeyDown: augmentHandler(externalInput.props.onKeyDown, onKeyDown),\n    onChange: augmentHandler(externalInput.props.onChange, onChange),\n    ref: inputRef\n  }));\n\n  /**\n   * Even thoughn we apply all the aria attributes, screen readers don't fully support this\n   * dynamic use case and so they don't have a native way to indicate to the user when\n   * there are suggestions available. So we use some hidden text with aria-live to politely\n   * indicate what's available and how to use it.\n   *\n   * This text should be consistent and the important info should be first, because users\n   * will hear it as they type - if they have heard the message before they should be able\n   * to recognize it and quickly apply the first suggestion without listening to the rest\n   * of the message.\n   *\n   * When screen reader users navigate using arrow keys, the `aria-activedescendant` will\n   * change and will be read out so we don't need to handle that interaction here.\n   */\n  var suggestionsDescription = !suggestionsVisible ? '' : suggestions === 'loading' ? 'Loading autocomplete suggestions…' : // It's important to include both Enter and Tab because we are telling the user that we are hijacking these keys:\n  \"\".concat(suggestions.length, \" autocomplete \").concat(suggestions.length === 1 ? 'suggestion' : 'suggestions', \" available; \\\"\").concat(getSuggestionValue(suggestions[0]), \"\\\" is highlighted. Press \").concat(tabInsertsSuggestions ? 'Enter or Tab' : 'Enter', \" to insert.\");\n  return /*#__PURE__*/(\n    // Try to get as close as possible to making the container 'invisible' by making it shrink tight to child input\n    React.createElement(Box, {\n      sx: _objectSpread(_objectSpread({\n        display: 'inline-block',\n        '& > *': {\n          width: '100%'\n        }\n      }, sx), {}, {\n        position: 'relative'\n      })\n    }, input, /*#__PURE__*/React.createElement(AutocompleteSuggestions, {\n      suggestions: suggestions,\n      inputRef: inputRef,\n      onCommit: onCommit,\n      onClose: onHideSuggestions,\n      top: suggestionsOffset.top,\n      left: suggestionsOffset.left,\n      visible: suggestionsVisible,\n      tabInsertsSuggestions: tabInsertsSuggestions\n    }), /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(\"span\", {\n      \"aria-live\": \"assertive\",\n      \"aria-atomic\": true,\n      style: {\n        clipPath: 'circle(0)',\n        position: 'absolute'\n      }\n    }, suggestionsDescription)))\n  );\n};\nInlineAutocomplete.displayName = \"InlineAutocomplete\";\nvar InlineAutocomplete$1 = InlineAutocomplete;\nexport { InlineAutocomplete$1 as default };","map":{"version":3,"names":["React","useRef","cloneElement","Box","Portal","getAbsoluteCharacterCoordinates","useSyntheticChange","requireChildrenToBeInput","augmentHandler","getSuggestionValue","calculateSuggestionsQuery","AutocompleteSuggestions","useRefObjectAsForwardedRef","getSelectionStart","element","selectionStart","e","TypeError","noop","InlineAutocomplete","triggers","suggestions","onShowSuggestions","onHideSuggestions","sx","children","tabInsertsSuggestions","forwardProps","_children$ref","_externalInput$props$","_getSelectionStart","inputRef","ref","externalInput","emitSyntheticChange","fallbackEventHandler","props","onChange","showEventRef","suggestionsVisible","length","triggerCharCoords","current","query","top","left","height","suggestionsOffset","onBlur","onKeyDown","event","key","stopPropagation","currentTarget","value","onCommit","suggestion","_getSelectionStart2","_trigger$keepTriggerC","trigger","currentCaretPosition","deleteLength","triggerChar","startIndex","keepTriggerChar","keepTriggerCharOnCommit","maybeTriggerChar","replacement","input","suggestionsDescription","createElement","display","width","position","onClose","visible","style","clipPath","displayName","InlineAutocomplete$1","default"],"sources":["/Users/mohammedalzafarani/Desktop/personalwebsite/node_modules/@primer/react/lib-esm/drafts/InlineAutocomplete/InlineAutocomplete.js"],"sourcesContent":["import React, { useRef, cloneElement } from 'react';\nimport Box from '../../Box.js';\nimport Portal from '../../Portal/index.js';\nimport { getAbsoluteCharacterCoordinates } from '../utils/character-coordinates.js';\nimport { useSyntheticChange } from '../hooks/useSyntheticChange.js';\nimport { requireChildrenToBeInput, augmentHandler, getSuggestionValue, calculateSuggestionsQuery } from './utils.js';\nimport AutocompleteSuggestions from './_AutocompleteSuggestions.js';\nimport { useRefObjectAsForwardedRef } from '../../hooks/useRefObjectAsForwardedRef.js';\n\nconst getSelectionStart = element => {\n  try {\n    return element.selectionStart;\n  } catch (e) {\n    // Safari throws an exception when trying to access selectionStart on date input element\n    if (e instanceof TypeError) return null;\n    throw e;\n  }\n};\nconst noop = () => {\n  // don't do anything\n};\n\n/**\n * Shows suggestions to complete the current word/phrase the user is actively typing.\n */\nconst InlineAutocomplete = ({\n  triggers,\n  suggestions,\n  onShowSuggestions,\n  onHideSuggestions,\n  sx,\n  children,\n  tabInsertsSuggestions = false,\n  // Forward accessibility props so it works with FormControl\n  ...forwardProps\n}) => {\n  var _children$ref, _externalInput$props$, _getSelectionStart;\n  const inputRef = useRef(null);\n  useRefObjectAsForwardedRef((_children$ref = children.ref) !== null && _children$ref !== void 0 ? _children$ref : noop, inputRef);\n  const externalInput = requireChildrenToBeInput(children, inputRef);\n  const emitSyntheticChange = useSyntheticChange({\n    inputRef,\n    fallbackEventHandler: (_externalInput$props$ = externalInput.props.onChange) !== null && _externalInput$props$ !== void 0 ? _externalInput$props$ : noop\n  });\n\n  /** Stores the query that caused the current suggestion list to appear. */\n  const showEventRef = useRef(null);\n  const suggestionsVisible = suggestions !== null && suggestions.length > 0;\n\n  // The suggestions don't usually move while open, so it seems as though this could be\n  // optimized by only re-rendering when suggestionsVisible changes. However, the user\n  // could move the cursor to a different location using arrow keys and then type a\n  // trigger, which would move the suggestions without closing/reopening them.\n  const triggerCharCoords = inputRef.current && showEventRef.current && suggestionsVisible ? getAbsoluteCharacterCoordinates(inputRef.current, ((_getSelectionStart = getSelectionStart(inputRef.current)) !== null && _getSelectionStart !== void 0 ? _getSelectionStart : 0) - showEventRef.current.query.length) : {\n    top: 0,\n    left: 0,\n    height: 0\n  };\n  const suggestionsOffset = {\n    top: triggerCharCoords.top + triggerCharCoords.height,\n    left: triggerCharCoords.left\n  };\n\n  // User can blur while suggestions are visible with shift+tab\n  const onBlur = () => {\n    onHideSuggestions();\n  };\n\n  // Even though the overlay has an Escape listener, it only works when focus is inside\n  // the overlay; in this case the textarea is focused\n  const onKeyDown = event => {\n    if (suggestionsVisible && event.key === 'Escape') {\n      onHideSuggestions();\n      event.stopPropagation();\n    }\n  };\n  const onChange = event => {\n    const selectionStart = getSelectionStart(event.currentTarget);\n    if (selectionStart === null) {\n      onHideSuggestions();\n      return;\n    }\n    showEventRef.current = calculateSuggestionsQuery(triggers, event.currentTarget.value, selectionStart);\n    if (showEventRef.current) {\n      onShowSuggestions(showEventRef.current);\n    } else {\n      onHideSuggestions();\n    }\n  };\n  const onCommit = suggestion => {\n    var _getSelectionStart2, _trigger$keepTriggerC;\n    if (!inputRef.current || !showEventRef.current) return;\n    const {\n      query,\n      trigger\n    } = showEventRef.current;\n    const currentCaretPosition = (_getSelectionStart2 = getSelectionStart(inputRef.current)) !== null && _getSelectionStart2 !== void 0 ? _getSelectionStart2 : 0;\n    const deleteLength = query.length + trigger.triggerChar.length;\n    const startIndex = currentCaretPosition - deleteLength;\n    const keepTriggerChar = (_trigger$keepTriggerC = trigger.keepTriggerCharOnCommit) !== null && _trigger$keepTriggerC !== void 0 ? _trigger$keepTriggerC : true;\n    const maybeTriggerChar = keepTriggerChar ? trigger.triggerChar : '';\n    const replacement = `${maybeTriggerChar}${suggestion} `;\n    emitSyntheticChange(replacement, [startIndex, startIndex + deleteLength]);\n    onHideSuggestions();\n  };\n  const input = /*#__PURE__*/cloneElement(externalInput, {\n    ...forwardProps,\n    onBlur: augmentHandler(externalInput.props.onBlur, onBlur),\n    onKeyDown: augmentHandler(externalInput.props.onKeyDown, onKeyDown),\n    onChange: augmentHandler(externalInput.props.onChange, onChange),\n    ref: inputRef\n  });\n\n  /**\n   * Even thoughn we apply all the aria attributes, screen readers don't fully support this\n   * dynamic use case and so they don't have a native way to indicate to the user when\n   * there are suggestions available. So we use some hidden text with aria-live to politely\n   * indicate what's available and how to use it.\n   *\n   * This text should be consistent and the important info should be first, because users\n   * will hear it as they type - if they have heard the message before they should be able\n   * to recognize it and quickly apply the first suggestion without listening to the rest\n   * of the message.\n   *\n   * When screen reader users navigate using arrow keys, the `aria-activedescendant` will\n   * change and will be read out so we don't need to handle that interaction here.\n   */\n  const suggestionsDescription = !suggestionsVisible ? '' : suggestions === 'loading' ? 'Loading autocomplete suggestions…' :\n  // It's important to include both Enter and Tab because we are telling the user that we are hijacking these keys:\n  `${suggestions.length} autocomplete ${suggestions.length === 1 ? 'suggestion' : 'suggestions'} available; \"${getSuggestionValue(suggestions[0])}\" is highlighted. Press ${tabInsertsSuggestions ? 'Enter or Tab' : 'Enter'} to insert.`;\n  return (\n    /*#__PURE__*/\n    // Try to get as close as possible to making the container 'invisible' by making it shrink tight to child input\n    React.createElement(Box, {\n      sx: {\n        display: 'inline-block',\n        '& > *': {\n          width: '100%'\n        },\n        ...sx,\n        position: 'relative'\n      }\n    }, input, /*#__PURE__*/React.createElement(AutocompleteSuggestions, {\n      suggestions: suggestions,\n      inputRef: inputRef,\n      onCommit: onCommit,\n      onClose: onHideSuggestions,\n      top: suggestionsOffset.top,\n      left: suggestionsOffset.left,\n      visible: suggestionsVisible,\n      tabInsertsSuggestions: tabInsertsSuggestions\n    }), /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(\"span\", {\n      \"aria-live\": \"assertive\",\n      \"aria-atomic\": true,\n      style: {\n        clipPath: 'circle(0)',\n        position: 'absolute'\n      }\n    }, suggestionsDescription)))\n  );\n};\nInlineAutocomplete.displayName = \"InlineAutocomplete\";\nvar InlineAutocomplete$1 = InlineAutocomplete;\n\nexport { InlineAutocomplete$1 as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}